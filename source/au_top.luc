module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }
  
  edge_detector button_detector(#RISE(1), #FALL(0),.clk(clk)); //detect on rising edge only 
  button_conditioner button_cond(.clk(clk));
  alu alu_machine;
  initial_board_states initial_states(.clk(clk), .rst(rst));  
  dff board_state[16](#INIT(b0011011111111111), .clk(clk), .rst(rst));
  fsm game_state(.clk(clk), .rst(rst)) = {IN_GAME, GAME_OVER};
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    button_cond.in = io_button[1];
    button_detector.in = button_cond.out; 
    
    initial_states.update_state = 0;
       
    case(game_state.q)
    {
      game_state.IN_GAME:
        io_led[2][7] = 0; // For debugging game_state
        if(button_detector.out)
        {
          alu_machine.button_pressed[7:0] = io_dip[0][7:0];
          alu_machine.button_pressed[15:8] = io_dip[1][7:0];
          alu_machine.state = board_state.q;
          board_state.d = alu_machine.out;
          if(alu_machine.game_over)
          {
            game_state.d = game_state.GAME_OVER;
          }
        }
        else
        {
          alu_machine.button_pressed = 16b0;
          alu_machine.state = board_state.q;
        }
      game_state.GAME_OVER:
        io_led[2][7] = 1; // For debugging game_state
        if(button_detector.out)
        {
          initial_states.update_state = 1;
          board_state.d = initial_states.out;
          game_state.d = game_state.IN_GAME; 
        } 
    }
    
    // Display current board state
    // Convert to external LED strip output
    io_led[0][7:0] = board_state.q[7:0];
    io_led[1][7:0] = board_state.q[15:8];
  }
}
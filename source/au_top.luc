module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    // output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    
    output led_strip[4],
    
    // output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    
    input button[16],
    input reset_button,
    input difficulty_button
    
    //input io_button [5],    // 5 buttons on IO Shield
    //input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }
  
  edge_detector button_detector[16](#RISE(1), #FALL(0),.clk(clk)); //detect on rising edge only 
  button_conditioner button_cond[16](.clk(clk));
  
  edge_detector reset_btn_detector(#RISE(1), #FALL(0), .clk(clk));
  button_conditioner reset_btn_cond(.clk(clk));
  
  edge_detector diff_btn_detector(#RISE(1), #FALL(0), .clk(clk));
  button_conditioner diff_btn_cond(.clk(clk));
  
  difficulty_level_control diff_control(.clk(clk), .rst(rst));
  
  alu alu_machine;
  initial_board_states initial_states(.clk(clk), .rst(rst));
  move_counter move_counter_module(.clk(clk), .rst(rst));  
  led_out led_out (.clk(clk), .rst(rst));
  
  dff board_state[16](#INIT(b0011011111111111), .clk(clk), .rst(rst));
  fsm game_state(.clk(clk), .rst(rst)) = {IN_GAME, GAME_OVER};
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    button_cond.in = button[15:0];
    button_detector.in = button_cond.out; 
    
    reset_btn_cond.in = reset_button;
    reset_btn_detector.in = reset_btn_cond.out;
    
    diff_btn_cond.in = difficulty_button;
    diff_btn_detector.in = diff_btn_cond.out;
    
    initial_states.update_state = 0;
    
    move_counter_module.inc = 0;
    move_counter_module.reset_counter = 0;
    
    diff_control.update_difficulty = 0;
    diff_control.update_move = 0;
    
    move_counter_module.difficulty = diff_control.difficulty;
       
    case(game_state.q)
    {
      game_state.IN_GAME:
        // io_led[2][7] = 0; // For debugging game_state
        if(button_detector.out != 16b0)
        {
          // update move count
          move_counter_module.inc = 1;
          
          // update difficulty counter
          diff_control.update_move = 1;
          
          // get new state using ALU  
          alu_machine.button_pressed = button_detector.out;
          alu_machine.state = board_state.q;
          board_state.d = alu_machine.out;
          
          // change to GAME_OVER state if board is solved
          if(alu_machine.game_over)
          {
            game_state.d = game_state.GAME_OVER;
          }
        }
        else
        {
          alu_machine.button_pressed = 16b0;
          alu_machine.state = board_state.q;
        }
        
        if (reset_btn_detector.out)
        {
          initial_states.update_state = 1;
          board_state.d = initial_states.out;
          move_counter_module.reset_counter = 1;
        }
        
        if (diff_btn_detector.out)
        {
          diff_control.update_difficulty = 1;
        }
      game_state.GAME_OVER:
        // io_led[2][7] = 1; // For debugging game_state
        
        if (reset_btn_detector.out)
        {
          game_state.d = game_state.IN_GAME;
          initial_states.update_state = 1;
          board_state.d = initial_states.out;
          // Reset move counter
          move_counter_module.reset_counter = 1;
        }
    }
      
    // Debugging board state on io led strip
    if (diff_control.hidden_turns == 0 | game_state.GAME_OVER)
    {
      led_out.power_on = 1;
      // io_led[0][7:0] = board_state.q[7:0];
      // io_led[1][7:0] = board_state.q[15:8];
    }
    else
    {
      led_out.power_on = 0;
      // io_led[0][7:0] = 8b0;
      // io_led[1][7:0] = 8b0;  
      // io_led[2][7:0] = 8b0;  
    }
    
      led_out.board_state = board_state.q;
      led_strip[0] = led_out.out0;
      led_strip[1] = led_out.out1;
      led_strip[2] = led_out.out2;
      led_strip[3] = led_out.out3;
    
    io_seg = move_counter_module.seg_out;
    io_sel = move_counter_module.sel_out;      
  }
}
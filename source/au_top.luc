module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }
  
  edge_detector button_detector(#RISE(1), #FALL(0),.clk(clk)); //detect on rising edge only 
  button_conditioner button_cond(.clk(clk));
  
  edge_detector reset_btn_detector(#RISE(1), #FALL(0), .clk(clk));
  button_conditioner reset_btn_cond(.clk(clk));
  
  edge_detector diff_btn_detector(#RISE(1), #FALL(0), .clk(clk));
  button_conditioner diff_btn_cond(.clk(clk));
  
  difficulty_level_control diff_control(.clk(clk), .rst(rst));
  
  alu alu_machine;
  initial_board_states initial_states(.clk(clk), .rst(rst));
  move_counter move_counter_module(.clk(clk), .rst(rst));  
  
  dff board_state[16](#INIT(b0011011111111111), .clk(clk), .rst(rst));
  fsm game_state(.clk(clk), .rst(rst)) = {IN_GAME, GAME_OVER};
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    button_cond.in = io_button[1];
    button_detector.in = button_cond.out; 
    
    reset_btn_cond.in = io_button[0];
    reset_btn_detector.in = reset_btn_cond.out;
    
    diff_btn_cond.in = io_button[2];
    diff_btn_detector.in = diff_btn_cond.out;
    
    initial_states.update_state = 0;
    
    move_counter_module.inc = 0;
    move_counter_module.reset_counter = 0;
    
    diff_control.update_difficulty = 0;
    diff_control.update_move = 0;
    
    move_counter_module.difficulty = diff_control.difficulty;
       
    case(game_state.q)
    {
      game_state.IN_GAME:
        io_led[2][7] = 0; // For debugging game_state
        if(button_detector.out)
        {
          // update move count
          move_counter_module.inc = 1;
          
          // update difficulty counter
          diff_control.update_move = 1;
          
          // get new state using ALU  
          alu_machine.button_pressed[7:0] = io_dip[0][7:0];
          alu_machine.button_pressed[15:8] = io_dip[1][7:0];
          alu_machine.state = board_state.q;
          board_state.d = alu_machine.out;
          
          // change to GAME_OVER state if board is solved
          if(alu_machine.game_over)
          {
            game_state.d = game_state.GAME_OVER;
          }
        }
        else
        {
          alu_machine.button_pressed = 16b0;
          alu_machine.state = board_state.q;
        }
        
        if (reset_btn_detector.out)
        {
          initial_states.update_state = 1;
          board_state.d = initial_states.out;
          move_counter_module.reset_counter = 1;
        }
        
        if (diff_btn_detector.out)
        {
          diff_control.update_difficulty = 1;
        }
      game_state.GAME_OVER:
        io_led[2][7] = 1; // For debugging game_state
        
        if (reset_btn_detector.out)
        {
          initial_states.update_state = 1;
          board_state.d = initial_states.out;
          // Reset move counter
          move_counter_module.reset_counter = 1;
        }
        
        //if(button_detector.out)
        //{
          // Reset move_counter
        //  move_counter_module.on_click = 1;
        //  move_counter_module.reset_counter = 1;
        //  num_moves = move_counter_module.out;  
          // Update states
        //  initial_states.update_state = 1;
        //  board_state.d = initial_states.out;
        //  game_state.d = game_state.IN_GAME; 
        //} 
    }
    
    // Debugging board state on io led strip
    if (!diff_control.hidden_turns)
    {
      io_led[0][7:0] = board_state.q[7:0];
      io_led[1][7:0] = board_state.q[15:8];
    }
    else
    {
      io_led[0][7:0] = 8b0;
      io_led[1][7:0] = 8b0;  
      io_led[2][7:0] = 8b0;  
    }
    
    io_seg = move_counter_module.seg_out;
    io_sel = move_counter_module.sel_out;
      
  }
}